# 브라우저 렌더링 과정

#### 1. 사용자가 브라우저 주소창에 https://example.com을 입력하고 엔터를 누르면, 어떤 과정으로 웹 페이지가 로딩되나요?

1. 사용자가 웹 브라우저를 통해 주소를 입력하면 URL 주소 중 도메인 부분을 DNS 서버에서 검색합니다.

- 이 때 브라우저는 로컬 DNS 캐시를 확인하여 최근에 조회한 도메인의 IP 주소가 있는지 확인합니다.
- 캐시에 없는 경우 DNS 서버에 조회 요청을 보냅니다.

2. DNS 서버에서 해당 도메인 주소에 해당하는 IP 주소를 찾아 사용자가 입력한 URL과 함께 전달합니다.

- 재귀적 탐색 : 로컬 DNS 서버가 필요한 모든 과정을 수행하여 직접 최종 응답 IP를 반환합니다.
- 반복적 탐색 : 클라이언트가 여러 DNS 서버를 순차적으로 탐색하여 최종 IP를 찾습니다.

3. IP 주소가 확인되면 브라우저는 서버와 TCP 연결을 수립합니다. TCP는 데이터를 신뢰성 있게 전달하기 위한 프로토콜로, 이 과정에서 브라우저는 서버와 3-way handshake를 수행합니다. 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.

4. 브라우저는 TCP 연결이 수립되면 HTTP 또는 HTTPS 프로토콜을 사용하여 요청 메세지를 생성합니다. 이 요청은 "GET/HTTP/1.1"과 같은 형식으로, 웹페이지를 요청하는 메세지 입니다. 

- HTTPS를 사용할 경우, 이 단계 이전에 SSL/TLS 핸드셰이크도 수행됩니다. 이 과정에서 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환하고 암호화 키를 협상합니다.

5. 서버는 요청을 받고, 해당 리소스를 브라우저에 응답으로 보냅니다.

6. 브라우저는 리소스를 바탕으로 브라우저 렌더링 파이프라인을 진행합니다.

#### 2-1. 브라우저가 화면에 렌더링 되는 과정

> 브라우저가 화면에 나타나는 요소를 렌더링 할 때, 웹킷(Webkit)이나 게코(Gecko)같은 렌더링 엔진을 사용합니다.

1. HTML 파싱 후, DOM(Document Object Model) 트리 구축
- DOM 트리는 HTML 문서의 구조를 트리 형태로 표현한 것으로, 각 태그가 node가 되어 부모-자식 관계를 형성

2. CSS 파싱 후, CSS 규칙들을 기반으로 CSSOM(CSS Object Model) 트리 구축
- CSS 규칙은 선택자(selector)와 선언(declaration)으로 구성
- 선택자는 스타일을 적용할 HTML 요소를 정의
- 선언은 적용할 스타일을 정의

3. Javascript 실행
4. DOM과 CSSOM을 조합하여 렌더 트리 구축
- 렌더 트리는 화면에 실제로 표시될 요소로만 구성
- 렌더 트리의 node는 DOM트리의 요소와 연결되며, CSSOM 트리에서 해당 요소에 적용된 스타일을 포함

5. 뷰포트 기반으로 렌더 트리의 각 노드가 가지는 정확한 위치와 크기 계산(Layout 단계)
6. 계산한 위치/크기를 기반으로 텍스트, 색상, 그림자, 이미지 등 시각적 요소를 화면에 그리는 단계(Paint 단계)
7. 요소 레이어를 결합하여 최종 화면을 출력하는 Composition 단계
- GPU를 활용해 각 레이어를 빠르게 합성
- transform, opacity같은 속성은 컴포지팅 단계에서만 처리
- GPU 가속을 활용하여 성능을 최적화하고, 화면에 최종적으로 표시되는 결과를 생성

#### 2-2. JavaScript는 왜 HTML 파싱을 블로킹(blocking)할 수 있을까요?

> HTML에서 자바스크립트 script를 만나면 script가 파싱됩니다. 이를 방지하기 위해서 백그라운드에서 동작할 수 있는 async, defer 태그를 사용합니다.

- async: HTML 파싱과 병렬로 JavaScript 다운로드 및 실행 (하지만 실행 순서 보장 X)
  - async로 로드된 스크립트는 다운로드가 끝나면 즉시 실행되어 다른 스크립트의 실행을 차단합니다.
- defer: HTML 파싱이 끝난 후 실행되며, 실행 순서가 보장됨
  - defer로 로드된 스크립트는 DOM이 상호작용 가능할때 실행되며 다른 동기적 스크립트의 실행을 차단하지 않습니다.

#### 2-3. Reflow와 Repaint의 차이점은 무엇이며, 성능 최적화를 위해 어떻게 줄일 수 있을까요?

> 렌더링이 반복되는 경우
>
> 1. 자바스크립트에 의한 노드의 추가/삭제
> 2. 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
> 3. HTML 요소의 레이아웃에 변경을 발생시키는 스타일 변경

- Reflow : Layout 단계에서 수정이 발생하여 각 노드 위치를 렌더 트리에 다시 렌더링 할 때 발생합니다. 상위 엘리먼트가 변경될 시 하위 엘리먼트에 영향을 끼치기 때문에 비싼 작업입니다.

- Repaint : Layout 과정에서 영향을 미치지 않고 변경된 요소를 화면에 그려줄 때 발생합니다. 요소의 모양이나 스타일이 변경될 때 발생합니다. 요소의 레이아웃은 그대로이고, 색상이나 배경 등의 스타일만 변경되는 경우를 말합니다.

### Reflow와 Repaint 최소화 방법

- position fixed, absolute는 다른 엘리먼트에 레이아웃에 영향을 주지 않기 때문에 비용을 줄일 수 있습니다.
- `display : none` 사용 시 Reflow, Repaint가 발생하지 않습니다.
- transform, opacity 속성 사용 시 이 두 속성은 GPU 가속을 사용할 수 있어 Reflow 없이 Repaint만 발생시키므로 CPU 자원을 적게 사용합니다.
- requestAnimationFrame() 메소드를 이용해 브라우저의 프레임 속도(60fps)에 맞추어 지연 및 블로킹 없이 콜백을 실행할 수 있습니다.
- will-change 속성을 사용하여 특정 요소의 변경을 미리 브라우저에 전달할 수 있습니다. `will-change: transform`으로 미리 GPU에서 요소를 준비하게 하여 reflow 및 repaint에 미치는 영향을 줄일 수 있습니다. 하지만 will-change 속성은 너무 자주 사용하면 메모리 낭비가 발생하므로 필요한 요소에만 적용해야 합니다.

### Javascript에서 Reflow 최소화 방법

- 스타일 적용 시 개별적으로 적용하지 않고 CSS class 변경으로 Reflow를 한번만 발생 시키도록 처리
- style.cssText를 사용하여 한번에 스타일 적용
- DOM을 직접 수정하는 대신 documentFragment를 사용해 한번의 Reflow만 발생시키도록 처리
